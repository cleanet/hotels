/*
 *   MIT License
 *
 *  Copyright (c) 2026 cleanet
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in all
 *  copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *  SOFTWARE.
 *
 * Generated by Proton Lumo
 */
package com.myenterprise.rest.annotation.sanitizehtml;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.ObjectWriter;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.myenterprise.rest.dto.JsonSanitizeDto;
import org.junit.jupiter.api.Test;
import org.openjdk.jmh.annotations.Mode;
import org.openjdk.jmh.annotations.OutputTimeUnit;
import org.openjdk.jmh.annotations.Scope;
import org.openjdk.jmh.annotations.State;
import org.openjdk.jmh.annotations.BenchmarkMode;
import org.openjdk.jmh.annotations.Param;
import org.openjdk.jmh.annotations.Setup;
import org.openjdk.jmh.annotations.Level;
import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.results.format.ResultFormatType;
import org.openjdk.jmh.runner.Runner;
import org.openjdk.jmh.runner.options.OptionsBuilder;
import org.openjdk.jmh.runner.options.TimeValue;

import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * JMH benchmark that measures the performance impact of the custom
 * {@link SanitizeHtmlResponse} serializer and {@link SanitizeHtmlRequestBody}
 * deserializer when working with a dynamically sized list of
 * {@link JsonSanitizeDto} objects.
 *
 * <p>The benchmark runs three scenarios:</p>
 * <ul>
 *   <li>Pure deserialization of a JSON array into a {@code List<JsonSanitizeDto>}
 *       ({@link #deserialize()})</li>
 *   <li>Pure serialisation of that list back to pretty‑printed JSON
 *       ({@link #serialize()})</li>
 *   <li>A full round‑trip (deserialise → serialise → deserialise)
 *       ({@link #roundTrip()})</li>
 * </ul>
 *
 * <p>A JUnit test method {@link #runAllBenchmarks()} launches the JMH runner
 * and writes the results to {@code target/jmh-dynamic-results.csv}. The size of
 * the generated JSON payload is controlled by the {@code @Param} field
 * {@link #elements}.</p>
 *
 * <p>All {@link String} values encountered during (de)serialisation are
 * processed by the custom sanitiser, thanks to the module registration in
 * {@link #setUp()}.</p>
 */
@State(Scope.Benchmark)                     // One instance shared across all benchmark threads
@BenchmarkMode(Mode.AverageTime)            // Measure average execution time per operation
@OutputTimeUnit(TimeUnit.MILLISECONDS)      // Report timings in milliseconds
public class JsonDynamicBenchmarkTest {

    /** Jackson mapper used for both reading and writing JSON. */
    private final ObjectMapper mapper = new ObjectMapper();

    /** Writer that produces pretty‑printed JSON output. */
    private final ObjectWriter prettyWriter = mapper.writerWithDefaultPrettyPrinter();

    /**
     * Parameter that controls how many elements the generated JSON array will
     * contain. JMH will run the benchmark for each value in the array.
     */
    @Param({"1", "10", "100", "1000", "2000"})
    public int elements;

    /** Holds the JSON payload generated for the current {@link #elements} size. */
    private String originalJson;

    /**
     * Sets up the benchmark environment before any measurement starts.
     *
     * <p>The method performs three tasks:</p>
     * <ol>
     *   <li>Creates a {@link SimpleModule} and registers the custom
     *       {@link SanitizeHtmlResponse} serializer and
     *       {@link SanitizeHtmlRequestBody} deserializer for {@link String}
     *       values.</li>
     *   <li>Registers the module with the {@link ObjectMapper} used by the
     *       benchmark.</li>
     *   <li>Generates a JSON array containing {@code elements} copies of a
     *       {@link JsonSanitizeDto} using {@link JsonGenerator}.</li>
     * </ol>
     *
     * @throws Exception if the JSON generation fails
     */
    @Setup(Level.Trial)
    public void setUp() throws Exception {

        SimpleModule htmlModule = new SimpleModule();
        htmlModule.addSerializer(String.class, new SanitizeHtmlResponse());
        htmlModule.addDeserializer(String.class, new SanitizeHtmlRequestBody());
        mapper.registerModule(htmlModule);

        originalJson = JsonGenerator.generateJsonArray(elements);
    }

    /**
     * Benchmark that measures the time taken to deserialize the JSON string
     * into a {@link List} of {@link JsonSanitizeDto}.
     *
     * @return the deserialised list (used only for timing, not for validation)
     * @throws Exception if Jackson encounters parsing errors
     */
    @Benchmark
    public List<JsonSanitizeDto> deserialize() throws Exception {
        return mapper.readValue(originalJson,
                new TypeReference<>() {});
    }

    /**
     * Benchmark that measures the time taken to serialise a previously
     * deserialised list of {@link JsonSanitizeDto} back to a pretty‑printed
     * JSON string.
     *
     * @return the JSON string produced by the writer
     * @throws Exception if either deserialisation or serialisation fails
     */
    @Benchmark
    public String serialize() throws Exception {
        List<JsonSanitizeDto> dto = mapper.readValue(originalJson,
                new TypeReference<>() {});
        return prettyWriter.writeValueAsString(dto);
    }

    /**
     * Benchmark that performs a full round‑trip: deserialize the original JSON,
     * serialise the resulting objects, and then deserialize the generated JSON
     * again. This measures the combined cost of both operations.
     *
     * @return the list obtained after the second deserialisation
     * @throws Exception if any step in the round‑trip fails
     */
    @Benchmark
    public List<JsonSanitizeDto> roundTrip() throws Exception {
        // First deserialization
        List<JsonSanitizeDto> dto = mapper.readValue(originalJson,
                new TypeReference<>() {});

        // Serialise to pretty JSON
        String json = prettyWriter.writeValueAsString(dto);

        // Second deserialization (the round‑trip)
        return mapper.readValue(json,
                new TypeReference<>() {});
    }

    /**
     * JUnit test that launches the JMH runner with a sensible configuration
     * and writes the benchmark results to {@code target/jmh-dynamic-results.csv}.
     *
     * <p>The runner performs five warm‑up iterations followed by ten measured
     * iterations, using a single fork. Results are exported in CSV format,
     * which can be opened in a spreadsheet for further analysis.</p>
     *
     * @throws Exception if the JMH runner encounters an error
     */
    @Test
    void runAllBenchmarks() throws Exception {
        new Runner(new OptionsBuilder()
                .include(this.getClass().getSimpleName()) // Run only this benchmark class
                .warmupIterations(5)                      // Warm‑up to stabilise the JVM
                .measurementIterations(10)                // Number of measured iterations
                .forks(1)                                 // Single JVM fork
                .timeUnit(java.util.concurrent.TimeUnit.MILLISECONDS)
                .timeout(TimeValue.seconds(30))           // Abort if a single iteration exceeds 30s
                // Export results to CSV for easy consumption
                .resultFormat(ResultFormatType.CSV)
                .result("target/jmh-dynamic-results.csv")
                .build()).run();
    }
}