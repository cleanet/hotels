/*
 *   MIT License
 *
 *  Copyright (c) 2026 cleanet
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in all
 *  copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *  SOFTWARE.
 *
 * Generated by Proton Lumo
 */
package com.myenterprise.rest.annotation.sanitizehtml;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.ObjectWriter;
import com.myenterprise.rest.dto.JsonSanitizeDto;
import org.junit.jupiter.api.Test;
import org.openjdk.jmh.annotations.*;
import org.openjdk.jmh.results.format.ResultFormatType;
import org.openjdk.jmh.runner.Runner;
import org.openjdk.jmh.runner.options.OptionsBuilder;
import org.openjdk.jmh.runner.options.TimeValue;

import java.io.InputStream;
import java.util.List;
import java.util.concurrent.TimeUnit;

import static org.junit.jupiter.api.Assertions.*;

/**
 * JMH benchmark that measures the performance impact of the custom
 * {@link SanitizeHtmlResponse} serializer and {@link SanitizeHtmlRequestBody}
 * deserializer
 *
 * <p>The benchmarks cover three scenarios:</p>
 * <ul>
 *   <li>Pure deserialization ({@link #deserialize()})</li>
 *   <li>Pure serialisation of a previously deserialised list
 *       ({@link #serialize()})</li>
 *   <li>A full round‑trip (deserialise → serialise → deserialise)
 *       ({@link #roundTrip()})</li>
 * </ul>
 *
 * <p>A JUnit test method {@link #runAllBenchmarks()} is provided to execute
 * the benchmarks and export the results to a CSV file. The test can be run
 * directly from an IDE or via Maven/Gradle.</p>
 *
 * <p>The class is annotated with JMH annotations to configure the benchmark
 * mode, output time unit and state scope.</p>
 */
@State(Scope.Benchmark)                     // One instance shared across all benchmark threads
@BenchmarkMode(Mode.AverageTime)            // Measure average execution time per operation
@OutputTimeUnit(TimeUnit.MILLISECONDS)      // Report timings in milliseconds
public class JsonBenchmarkTest {

    /** Jackson mapper used for both reading and writing JSON. */
    private final ObjectMapper mapper = new ObjectMapper();

    /** Writer that produces pretty‑printed JSON output. */
    private final ObjectWriter prettyWriter = mapper.writerWithDefaultPrettyPrinter();

    /** Holds the raw JSON payload loaded from {@code responseList.json}. */
    private String originalJson;

    /**
     * Loads the JSON fixture from the class‑path before any benchmark iteration.
     *
     * @throws Exception if the resource cannot be found or read
     */
    @Setup(Level.Trial)
    public void setUp() throws Exception {
        InputStream stream = getClass()
                .getClassLoader()
                .getResourceAsStream("responseList.json");
        assert stream != null;
        originalJson = new String(stream.readAllBytes());
    }

    /**
     * Benchmark that measures the time taken to deserialize the JSON string
     * into a {@link List} of {@link JsonSanitizeDto}.
     *
     * @return the deserialised list (used only for timing, not for validation)
     * @throws Exception if Jackson encounters parsing errors
     */
    @Benchmark
    public List<JsonSanitizeDto> deserialize() throws Exception {
        List<JsonSanitizeDto> object =  mapper.readValue(originalJson,
                new TypeReference<>() {});
        assertFalse(
                object.get(0).getDescription().contains("<script>alert('xss')</script>")
        );
        return object;
    }

    /**
     * Benchmark that measures the time taken to serialise a previously
     * deserialized list of {@link JsonSanitizeDto} back to a pretty‑printed
     * JSON string.
     *
     * @return the JSON string produced by the writer
     * @throws Exception if either deserialization or serialisation fails
     */
    @Benchmark
    public String serialize() throws Exception {
        List<JsonSanitizeDto> dto = mapper.readValue(originalJson,
                new TypeReference<>() {});
        String value = prettyWriter.writeValueAsString(dto);
        assertFalse( value.contains("<script>alert('xss')</script>") );
        return value;
    }

    /**
     * Benchmark that performs a full round‑trip: deserialize the original JSON,
     * serialise the resulting objects, and then deserialize the generated JSON
     * again. This measures the combined cost of both operations.
     *
     * @return the list obtained after the second deserialization
     * @throws Exception if any step in the round‑trip fails
     */
    @Benchmark
    public List<JsonSanitizeDto> roundTrip() throws Exception {
        // First deserialization
        List<JsonSanitizeDto> dto = mapper.readValue(originalJson,
                new TypeReference<>() {});

        // Serialise to pretty JSON
        String json = prettyWriter.writeValueAsString(dto);

        // Second deserialization (the round‑trip)
        return mapper.readValue(json,
                new TypeReference<>() {});
    }

    /**
     * JUnit test that launches the JMH runner with a sensible configuration
     * and writes the benchmark results to {@code target/jmh-results.csv}.
     *
     * <p>The runner performs five warm‑up iterations followed by ten measured
     * iterations, using a single fork. Results are exported in CSV format,
     * which can be opened in spreadsheets for further analysis.</p>
     *
     * @throws Exception if the JMH runner encounters an error
     */
    @Test
    void runAllBenchmarks() throws Exception {
        new Runner(new OptionsBuilder()
                .include(this.getClass().getSimpleName()) // Run only this benchmark class
                .warmupIterations(5)                      // Warm‑up to stabilise the JVM
                .measurementIterations(10)                // Number of measured iterations
                .forks(1)                                 // Single JVM fork
                .timeUnit(java.util.concurrent.TimeUnit.MILLISECONDS)
                .timeout(TimeValue.seconds(30))           // Abort if a single iteration exceeds 30 s
                // Export results to CSV for easy consumption
                .resultFormat(ResultFormatType.CSV)
                .result("target/jmh-results.csv")
                .build()).run();
    }
}