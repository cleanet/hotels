/*
 *   MIT License
 *
 *  Copyright (c) 2026 cleanet
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in all
 *  copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *  SOFTWARE.
 *
 * Generated by Proton Lumo
 */
package com.myenterprise.rest.annotation.sanitizehtml;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.ObjectWriter;
import com.myenterprise.rest.dto.JsonSanitizeDto;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Unit‑tests that verify the dynamic‑size JSON (de)serialisation of
 * {@link JsonSanitizeDto} objects while applying the custom HTML‑sanitising
 * logic.
 *
 * <p>The tests use a plain {@link ObjectMapper} – no custom module is registered
 * here because the sanitiser is expected to be applied globally in the
 * application configuration (or via field‑level annotations on the DTO). The
 * purpose of the tests is to ensure that:</p>
 * <ul>
 *   <li>Deserialising a JSON array of varying length yields the correct number
 *       of DTO instances.</li>
 *   <li>Serialising the DTOs back to JSON produces a different, pretty‑printed
 *       representation (the sanitiser may have altered the content).</li>
 *   <li>Any potentially dangerous HTML (e.g. {@code <script>} tags) is removed
 *       from the {@code description} field after a round‑trip.</li>
 * </ul>
 *
 * <p>All assertions are written with JUnit 5 and the tests are deliberately
 * lightweight – they do not depend on external resources.</p>
 */
class SanitizeHtmlDynamicTest {

    /** Shared Jackson mapper used for reading and writing JSON. */
    private final ObjectMapper mapper = new ObjectMapper();

    /** Writer that produces pretty‑printed JSON output for easier visual comparison. */
    private final ObjectWriter prettyWriter = mapper.writerWithDefaultPrettyPrinter();

    /**
     * Parameterised test that checks deserialization of a JSON array whose size
     * is supplied by the {@code @CsvSource}. The test runs once for each value
     * (1, 10, 100, 1000 and 2000).
     *
     * <p>The workflow is:</p>
     * <ol>
     *   <li>Generate a JSON array containing {@code elements} copies of a
     *       {@link JsonSanitizeDto} using {@link JsonGenerator}.</li>
     *   <li>Pretty‑print the original JSON solely for a visual sanity check.</li>
     *   <li>Deserialize the array into a {@code List<JsonSanitizeDto>}.</li>
     *   <li>Serialise the list back to pretty‑printed JSON.</li>
     *   <li>Deserialize the pretty‑printed JSON again (round‑trip).</li>
     *   <li>Assert that the pretty‑printed forms differ (the sanitiser may have
     *       altered the content) and that the round‑trip list is non‑empty,
     *       has the expected size, and contains no {@code <script>} tags.</li>
     * </ol>
     *
     * @param elements the number of DTO objects to generate in the JSON array
     * @throws Exception if any Jackson operation fails
     */
    @ParameterizedTest(name = "List with {0} elements")
    @CsvSource({
            "1",
            "10",
            "100",
            "1000",
            "2000"
    })
    public void deserializeList_dynamicSize(int elements) throws Exception {
        String originalJson = JsonGenerator.generateJsonArray(elements);

        String originalPretty = new ObjectMapper()
                .writerWithDefaultPrettyPrinter()
                .writeValueAsString(mapper.readTree(originalJson));

        List<JsonSanitizeDto> example = mapper.readValue(originalJson,
                new TypeReference<>() {});

        String serializedPretty = prettyWriter.writeValueAsString(example);
        List<JsonSanitizeDto> roundTrip = mapper.readValue(serializedPretty,
                new TypeReference<>() {});

        assertNotEquals(originalPretty, serializedPretty);

        // The round‑trip list must contain elements and match the expected size.
        assertFalse(roundTrip.isEmpty(),
                "Round‑trip list should not be empty");
        assertEquals(elements, roundTrip.size(),
                "Round‑trip list size should match the generated size");

        // Verify that no DTO still contains a <script> tag in its description.
        for (JsonSanitizeDto dto : roundTrip) {
            assertFalse(dto.getDescription().contains("<script>"),
                    "The script XSS tag should have been removed");
        }
    }

    /**
     * Simple test that validates (de)serialisation of a single
     * {@link JsonSanitizeDto} instance.
     *
     * <p>The steps mirror those of the dynamic test but operate on a single
     * object rather than a collection:</p>
     * <ol>
     *   <li>Generate a single JSON object using {@link JsonGenerator}.</li>
     *   <li>Pretty‑print the original JSON for visual comparison.</li>
     *   <li>Deserialize the JSON into a {@code JsonSanitizeDto}.</li>
     *   <li>Serialise the DTO back to pretty‑printed JSON.</li>
     *   <li>Deserialize the pretty‑printed JSON again (round‑trip).</li>
     *   <li>Assert that the pretty‑printed forms differ and that the
     *       {@code description} field no longer contains a {@code <script>}
     *       tag.</li>
     * </ol>
     *
     * @throws Exception if any Jackson operation fails
     */
    @Test
    public void deserialize_singleObject() throws Exception {
        String originalJson = JsonGenerator.generateSingleJson();
        String originalPretty = prettyWriter.writeValueAsString(mapper.readTree(originalJson));

        JsonSanitizeDto example = mapper.readValue(originalJson, JsonSanitizeDto.class);
        String serializedPretty = prettyWriter.writeValueAsString(example);
        JsonSanitizeDto roundTrip = mapper.readValue(serializedPretty, JsonSanitizeDto.class);

        assertNotEquals(originalPretty, serializedPretty,
                "The pretty‑printed JSON should differ after sanitisation");
        assertFalse(roundTrip.getDescription().contains("<script>"),
                "The script XSS tag should have been removed from the description");
    }
}